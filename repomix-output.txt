This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-03T07:45:00.735Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
backend/
  app/
    __init__.py
    routes.py
  config/
    __init__.py
  __init__.py
  .gitignore
  run.py
frontend/
  public/
    index.html
    manifest.json
    robots.txt
  src/
    components/
      Nav.js
      Notes.js
      TranscriptManager.js
      VideoCall.js
    context/
      NotesContext.js
      TranscriptContext.js
    pages/
      landing.js
      meeting.js
      summary.js
    styles/
      Nav.css
      notes.css
      summary.css
    App.css
    App.js
    App.test.js
    index.css
    index.js
    logo.svg
    reportWebVitals.js
    setupTests.js
  .gitignore
  package.json
  README.md
src/
  services/
    __init__.py
    email_service.py
  utils/
    __init__.py
    context_provider.py
    query_generator.py
  __init__.py
  agent.py
.gitignore
README.md
requirements.txt
setup.py

================================================================
Repository Files
================================================================

================
File: backend/app/__init__.py
================
from flask import Flask
from config import Config
from asgiref.wsgi import WsgiToAsgi
from flask_cors import CORS

def create_app():
    app = Flask(__name__)
    app.config.from_object(Config)
    
    # Enable CORS for all routes
    CORS(app, resources={
        r"/*": {
            "origins": ["http://localhost:3000"],  # React's default port
            "methods": ["GET", "POST", "OPTIONS"],
            "allow_headers": ["Content-Type"]
        }
    })

    # Register blueprints
    from app.routes import main
    app.register_blueprint(main)

    # Wrap with ASGI for async support
    asgi_app = WsgiToAsgi(app)
    return asgi_app, app

================
File: backend/app/routes.py
================
from flask import Blueprint, request, jsonify
from src.agent import EmailQueryAgent, MeetingAnalysisAgent
from config import Config

main = Blueprint('main', __name__)

# Initialize with OpenAI
email_agent = EmailQueryAgent(
    llm_provider="openai",
    api_key=Config.OPENAI_API_KEY
)

meeting_agent = MeetingAnalysisAgent(
    api_key=Config.ANTHROPIC_API_KEY
)

@main.route('/health', methods=['GET'])
def health_check():
    return jsonify({'status': 'healthy'}), 200

from flask import Blueprint, request, jsonify
from src.agent import MeetingAnalysisAgent
from config import Config

main = Blueprint('main', __name__)

# Initialize the MeetingAnalysisAgent
meeting_agent = MeetingAnalysisAgent(api_key=Config.ANTHROPIC_API_KEY)

@main.route('/health', methods=['GET'])
def health_check():
    return jsonify({'status': 'healthy'}), 200

@main.route('/analyze-transcript', methods=['POST'])
async def analyze_transcript():
    """
    Endpoint to analyze transcript segments and update meeting summary
    
    Expected JSON payload:
    {
        "transcript": "Text with timestamps and messages..."
    }
    """
    try:
        data = request.get_json()
        if not data or 'transcript' not in data:
            return jsonify({
                'error': 'No transcript provided'
            }), 400

        # Get the transcript text
        transcript = data['transcript']
        print("Received transcript:", transcript)  # Debug log

        # Process transcript for summary update - pass transcript directly
        updated_summary = meeting_agent.process_segment(
            existing_summary='',  # Start fresh each time
            new_transcript=transcript  # Pass the formatted transcript directly
        )

        print("Updated summary:", updated_summary)  # Debug log
        
        return jsonify({
            'status': 'success',
            'results': {
                'summary': updated_summary
            }
        }), 200
    
    except Exception as e:
        print("Error processing transcript:", str(e))  # Debug log
        return jsonify({
            'error': str(e),
            'status': 'error'
        }), 500


@main.route('/demo-queries', methods=['GET'])
async def demo_queries():
    """Demo endpoint with sample transcripts and their analysis"""
    
    sample_transcripts = [
        {
            "scenario": "Budget Review Email",
            "transcript": """
            John: Hey team, can someone forward me that email Sarah sent last week about the Q4 budget review?
            Mary: The one with the Excel spreadsheet attachments?
            John: Yeah, the one she sent to the whole finance team on Thursday.
            Bob: I think it had 'FY24 Q4 Budget Final' in the subject line.
            """
        },
        {
            "scenario": "Marketing Campaign PDF",
            "transcript": """
            Alice: Has anyone seen the marketing presentation Janet sent yesterday?
            Bob: Was it the PDF with the new campaign designs?
            Alice: Yes, she sent it to the marketing team with all the Q1 plans.
            """
        },
        {
            "scenario": "Project Timeline",
            "transcript": """
            Mike: Could you find that email thread from David about project timelines?
            Sarah: The one from last month with the Gantt chart attached?
            Mike: Yes, he sent it to all project managers with subject 'Updated 2024 Roadmap'
            """
        }
    ]
    
    try:
        results = []
        for sample in sample_transcripts:
            analysis = await email_agent.analyze_transcript_segment(sample["transcript"])
            results.append({
                "scenario": sample["scenario"],
                "transcript": sample["transcript"],
                "analysis": analysis
            })
        
        return jsonify({
            'status': 'success',
            'sample_analyses': results
        }), 200
    
    except Exception as e:
        return jsonify({
            'error': str(e),
            'status': 'error'
        }), 500
    
@main.route('/test-email', methods=['POST'])
async def test_email():
    """Endpoint for direct email queries from chat"""
    try:
        data = request.get_json()
        query = data.get('query', '')
        
        if not query:
            return jsonify({
                'error': 'No query provided',
                'status': 'error'
            }), 400

        analysis_results = await email_agent.analyze_transcript_segment(query)
        
        return jsonify({
            'status': 'success',
            'results': analysis_results
        }), 200
    
    except Exception as e:
        return jsonify({
            'error': str(e),
            'status': 'error'
        }), 500

================
File: backend/config/__init__.py
================
import os
from dotenv import load_dotenv

load_dotenv()

class Config:
    # API Keys
    OPENAI_API_KEY = os.getenv('OPENAI_API_KEY')
    ANTHROPIC_API_KEY = os.getenv('ANTHROPIC_API_KEY')
    
    # LLM Configuration
    DEFAULT_LLM_PROVIDER = "openai"  # or "anthropic"
    
    # OpenAI specific settings
    OPENAI_MODEL = "gpt-4o-mini"
    OPENAI_TEMPERATURE = 0.1
    
    # Anthropic specific settings
    ANTHROPIC_MODEL = "claude-3-5-sonnet-20241022"

    # CORS Configuration
    CORS_HEADERS = 'Content-Type'
    
    # Frontend URL (for CORS)
    FRONTEND_URL = os.getenv('FRONTEND_URL', 'http://localhost:3000')

    # Email Configuration
    GOOGLE_CLIENT_ID = os.getenv('GOOGLE_CLIENT_ID')
    GOOGLE_CLIENT_SECRET = os.getenv('GOOGLE_CLIENT_SECRET')
    GOOGLE_CREDENTIALS_FILE = 'credentials.json'
    GOOGLE_TOKEN_FILE = 'token.json'

================
File: backend/__init__.py
================
"""
Backend package initialization.
This file marks the backend directory as a Python package and can contain package-level configuration.
"""

from pathlib import Path

# Define important paths
BACKEND_ROOT = Path(__file__).parent
PROJECT_ROOT = BACKEND_ROOT.parent

# Version info
__version__ = "0.1.0"

# Package level constants
API_PREFIX = "/api/v1"
DEFAULT_HOST = "0.0.0.0"
DEFAULT_PORT = 5000

# You can add more package-level configuration here

================
File: backend/.gitignore
================
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
env/
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
*.egg-info/
.installed.cfg
*.egg

# Environment variables
.env

# IDE
.idea/
.vscode/
*.swp
*.swo

# OS
.DS_Store

================
File: backend/run.py
================
import os
import sys
from pathlib import Path

# Add project root to Python path
project_root = Path(__file__).parent.parent.absolute()
sys.path.append(str(project_root))

import asyncio
from hypercorn.config import Config
from hypercorn.asyncio import serve
from app import create_app

asgi_app, flask_app = create_app()

if __name__ == '__main__':
    config = Config()
    config.bind = ["0.0.0.0:5000"]
    asyncio.run(serve(asgi_app, config))

================
File: frontend/public/index.html
================
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Web site created using create-react-app"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>React App</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>

================
File: frontend/public/manifest.json
================
{
  "short_name": "React App",
  "name": "Create React App Sample",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}

================
File: frontend/public/robots.txt
================
# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:

================
File: frontend/src/components/Nav.js
================
// src/components/Nav.js
import React from 'react';
import { Link } from 'react-router-dom';
import '../styles/Nav.css';

export const Nav = () => {
    return (
      <div className="nav">
        <Link to='/' className="logo-link">
          <div className='logo'>Convene<span className="gradient-text">AI</span></div>
        </Link>
        <Link to='/meeting' className="logo-link">
            <div className="join">Join A Meeting</div>
        </Link>
      </div>
    );
}

export default Nav;

================
File: frontend/src/components/Notes.js
================
// src/components/Notes.js
import React, { useEffect, useState } from 'react';
import ReactMarkdown from 'react-markdown';
import '../styles/notes.css';
import { useNotes } from '../context/NotesContext';

const Notes = () => {
  const { notes } = useNotes();
  const [typedNotes, setTypedNotes] = useState(new Set());

  useEffect(() => {
    console.log('Notes: Current notes count:', notes.length);
  }, [notes]);

  const handleAnimationEnd = (index) => {
    console.log('Notes: Animation ended for note:', index);
    setTypedNotes((prev) => new Set(prev).add(index));
  };

  console.log('Notes: Rendering with notes:', notes);

  return (
    <div className="notes-container">
      <div className="tab-buttons">
        <button className="tab-button active">Notes</button>
      </div>

      <div className="static-notes">
        {notes.map((note, index) => {
          console.log(`Notes: Rendering note ${index}:`, note.slice(0, 50) + '...');
          return (
            <div
              key={index}
              className={`note ${typedNotes.has(index) ? 'typed' : 'typewriter'}`}
              onAnimationEnd={() => handleAnimationEnd(index)}
            >
              <ReactMarkdown>{note}</ReactMarkdown>
            </div>
          );
        })}
      </div>
    </div>
  );
};

export default Notes;

================
File: frontend/src/components/TranscriptManager.js
================
// src/components/TranscriptManager.js
import React, { useEffect, useState } from 'react';
import { useTranscript } from '../context/TranscriptContext';
import { useNotes } from '../context/NotesContext';

const TranscriptManager = () => {
  const { transcriptBuffer, getFormattedTranscript, clearBuffer } = useTranscript();
  const { addNote } = useNotes();
  const [existingSummary, setExistingSummary] = useState("");

  // Function to send transcript and existing summary to backend
  const processTranscript = async (transcript) => {
    try {
      console.log('TranscriptManager: Sending transcript and summary to backend:', { existingSummary, transcript });

      const response = await fetch('http://localhost:5000/analyze-transcript', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          transcript: transcript,
          existing_summary: existingSummary // Pass the current summary
        }),
      });

      const data = await response.json();
      console.log('TranscriptManager: Backend response:', data);

      if (data && data.results && data.results.summary) {
        setExistingSummary(data.results.summary); // Update summary
        addNote(data.results.summary); // Add new note to context
        console.log('TranscriptManager: Updated summary and added new note');
      }

      // Clear the buffer after processing
      clearBuffer();
      console.log('TranscriptManager: Cleared transcript buffer');
    } catch (error) {
      console.error('TranscriptManager: Error processing transcript:', error);
    }
  };

  // Watch transcript buffer
  useEffect(() => {
    if (transcriptBuffer.length >= 10) {
      const transcript = getFormattedTranscript();
      console.log('TranscriptManager: Buffer reached 10 messages:', transcript);
      processTranscript(transcript);
    }
  }, [transcriptBuffer, getFormattedTranscript, clearBuffer]);

  // This component doesn't render anything
  return null;
};

export default TranscriptManager;

================
File: frontend/src/components/VideoCall.js
================
// src/components/VideoCall.js
import React, { useEffect, useRef, useState } from 'react';
import DailyIframe from '@daily-co/daily-js';
import { useNotes } from '../context/NotesContext';

const VideoCall = ({ url }) => {
  const videoContainerRef = useRef(null);
  const callFrameRef = useRef(null);
  const [transcriptBuffer, setTranscriptBuffer] = useState([]);
  const { addNote } = useNotes();

  useEffect(() => {
    console.log("VideoCall: Component mounting");
    if (!callFrameRef.current) {
      console.log("VideoCall: Creating DailyIframe instance");
      callFrameRef.current = DailyIframe.createFrame(videoContainerRef.current, {
        showLeaveButton: true,
        showFullscreenButton: true,
        iframeStyle: {
          width: '100%',
          height: '100%',
        },
      });

      const token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJvIjp0cnVlLCJkIjoiNmI2YWQzMzYtNjZhMS00NDk2LWI3NWItMTQ5YTk1NGE5ZjAwIiwiaWF0IjoxNzMwNjAyMTU2fQ.2LAsgzL82X1JfxvDOGiLsajaERRCGWkSjtKX3u66NLc';

      callFrameRef.current.join({ url, token }).then(() => {
        console.log("VideoCall: Joined call, starting transcription");
        callFrameRef.current.startTranscription();
        console.log("VideoCall: Transcription started");
      });

      callFrameRef.current.on('app-message', (message) => {
        console.log('VideoCall: Received app message:', message);
        setTranscriptBuffer((prevBuffer) => {
          const updatedBuffer = [...prevBuffer, message.data];
          console.log('VideoCall: Current buffer size:', updatedBuffer.length);
          
          if (updatedBuffer.length >= 10) {
            console.log('VideoCall: Buffer full (10 messages), processing transcript');
            const formattedTranscript = updatedBuffer
              .map((msg) => `[${msg.timestamp}] ${msg.user_name || ""}: ${msg.text}`)
              .join('\n');
            console.log('VideoCall: Formatted transcript:', formattedTranscript);
            sendTranscriptToBackend(formattedTranscript);
            return [];
          }
          return updatedBuffer;
        });
      });
    }

    return () => {
      console.log("VideoCall: Cleaning up");
      if (callFrameRef.current) {
        callFrameRef.current.leave();
        callFrameRef.current.destroy();
        callFrameRef.current = null;
      }
    };
  }, [url]);

  const sendTranscriptToBackend = async (transcript) => {
    try {
      console.log('VideoCall: Sending transcript to backend:', transcript);
      
      const response = await fetch('http://localhost:5000/analyze-transcript', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ transcript }),
      });

      const data = await response.json();
      console.log('VideoCall: Received response from backend:', data);
      
      if (data && data.results && data.results.summary) {
        console.log('VideoCall: Adding new note to context:', data.results.summary);
        addNote(data.results.summary);
      }
    } catch (error) {
      console.error("VideoCall: Error sending transcript:", error);
    }
  };

  return <div ref={videoContainerRef} style={{ width: '100%', height: '100%' }} />;
};

export default VideoCall;

================
File: frontend/src/context/NotesContext.js
================
// src/context/NotesContext.js
import React, { createContext, useContext, useState, useCallback } from 'react';

const NotesContext = createContext();

export const NotesProvider = ({ children }) => {
  const [notes, setNotes] = useState([]);

  const addNote = useCallback((note) => {
    console.log('NotesContext: Adding new note:', note.slice(0, 50) + '...');
    setNotes((prevNotes) => {
      const newNotes = [...prevNotes, note];
      console.log('NotesContext: New notes count:', newNotes.length);
      return newNotes;
    });
  }, []);

  const clearNotes = useCallback(() => {
    console.log('NotesContext: Clearing all notes');
    setNotes([]);
  }, []);

  console.log('NotesContext: Current notes count:', notes.length);

  return (
    <NotesContext.Provider value={{ notes, addNote, clearNotes }}>
      {children}
    </NotesContext.Provider>
  );
};

export const useNotes = () => {
  const context = useContext(NotesContext);
  if (!context) {
    console.error('NotesContext: useNotes must be used within a NotesProvider');
    throw new Error('useNotes must be used within a NotesProvider');
  }
  return context;
};

================
File: frontend/src/context/TranscriptContext.js
================
// src/context/TranscriptContext.js
import React, { createContext, useContext, useState, useCallback } from 'react';

const TranscriptContext = createContext();

export function TranscriptProvider({ children }) {
  const [transcriptBuffer, setTranscriptBuffer] = useState([]);
  const [processedMessages, setProcessedMessages] = useState(new Set());

  const addMessage = useCallback((message) => {
    setTranscriptBuffer(prev => {
      // Only add message if it hasn't been processed
      if (!processedMessages.has(message.id)) {
        const newBuffer = [...prev, message];
        
        // Keep only the latest 10 messages
        const finalBuffer = newBuffer.slice(-10);
        
        // Mark message as processed
        setProcessedMessages(prevSet => new Set([...prevSet, message.id]));
        
        return finalBuffer;
      }
      return prev;
    });
  }, [processedMessages]);

  const clearBuffer = useCallback(() => {
    setTranscriptBuffer([]);
  }, []);

  const getFormattedTranscript = useCallback(() => {
    return transcriptBuffer
      .map(msg => `[${msg.timestamp}] ${msg.userName}: ${msg.text}`)
      .join('\n');
  }, [transcriptBuffer]);

  return (
    <TranscriptContext.Provider 
      value={{
        transcriptBuffer,
        addMessage,
        clearBuffer,
        getFormattedTranscript
      }}
    >
      {children}
    </TranscriptContext.Provider>
  );
}

export function useTranscript() {
  const context = useContext(TranscriptContext);
  if (!context) {
    throw new Error('useTranscript must be used within a TranscriptProvider');
  }
  return context;
}

================
File: frontend/src/pages/landing.js
================
import React from 'react';
import { Link } from 'react-router-dom';

export const Landing = () => {
  return (
    <div>Landing</div>
  );
}

export default Landing;

================
File: frontend/src/pages/meeting.js
================
import React from 'react';
import { BrowserRouter as Router, Routes, Route } from "react-router-dom";
import VideoCall from '../components/VideoCall';
import Notes from '../components/Notes';
import '../App.css';

export const Meeting = () => {
  const dailyUrl = 'https://conveneai.daily.co/conveneAI';

  return (
    <div className="app-container">
      <div className="video-section">
        <VideoCall url={dailyUrl} />
      </div>
      <div className="notes-section">
        <Notes />
      </div>
    </div>
  );
};

export default Meeting;

================
File: frontend/src/pages/summary.js
================
import React from 'react';
import { Link } from 'react-router-dom';
import Nav from '../components/Nav';
import '../styles/summary.css';

export const Summary = () => {
  return (
    <div>
        <Nav></Nav>
        <div className="container">
            <div className="left-section">
                <div className="recording">

                </div>
                <div className="notes">

                </div>
            </div>
            <div className="chat">

            </div>
        </div>
    </div>
  );
}

export default Summary;

================
File: frontend/src/styles/Nav.css
================
.nav {
    display: flex;
    justify-content: space-between;
    align-items: center;

    width: 100vw;
    height: 8vh;

    background-color: #ffffff;
}

.logo {
    color: black;
    font-size: 20px;
    font-weight: 900;
    margin: 0 30px;

    text-decoration: none;
}

.logo-link {
    text-decoration: none; /* Remove underline from Link */
}

.join {
    background-color: black;
    color: white;
    padding: 10px 20px;
    border-radius: 5px;
    margin: 0 30px;
    cursor: pointer;
    font-weight: bold;
    transition: background-color 0.3s ease;
}

.join:hover {
    background-color: #333333; /* Darker black on hover */
}

.gradient-text {
    background: linear-gradient(to right, #4a90e2, #50e3c2); /* Adjust the gradient colors */
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    font-weight: bold; /* Optional: Adjust thickness if needed */
}

================
File: frontend/src/styles/notes.css
================
/* Notes.css */

/* Main Notes container */
.notes-container {
    padding: 20px;
    height: 100%;
    overflow-y: auto;
  }
  
  /* Tab navigation styling */
  .tab-buttons {
    display: flex;
    margin-bottom: 15px;
    gap: 8px;
  }
  
  .tab-button {
    flex: 1;
    padding: 10px;
    background-color: #f8f9fa;
    color: #333;
    border: 1px solid #ddd;
    border-radius: 6px;
    cursor: pointer;
    font-weight: 600;
    transition: background-color 0.3s ease, color 0.3s ease;
  }
  
  .tab-button.active {
    background-color: #4b7bec;
    color: #fff;
  }
  
  .tab-button:hover {
    background-color: #e0e4ff;
  }
  
  /* Static style for Notes tab */
  .static-notes {
    font-family: 'Georgia', serif;
    color: #333;
    font-size: 16px;
    line-height: 1.6;
    padding: 10px;
    border-left: 4px solid #ddd;
    margin-bottom: 20px;
    transition: color 0.3s ease;
  }
  
  /* Combined typewriter effect with cursor blinking for new notes */
  .typewriter {
    display: inline-block;
    overflow: hidden;
    white-space: nowrap;
    border-right: 2px solid #333; /* Blinking cursor */
    animation: typing 2s steps(30, end) forwards, blink-cursor 0.75s step-end infinite;
  }
  
  /* Typing animation */
  @keyframes typing {
    from { width: 0; }
    to { width: 100%; }
  }
  
  /* Cursor blinking effect */
  @keyframes blink-cursor {
    from, to { border-color: transparent; }
    50% { border-color: #333; }
  }
  
  /* Styling for notes that are already typed */
  .typed {
    white-space: normal;
    border: none; /* Remove cursor for typed notes */
  }
  
  /* Content area for Chat */
  .content-area {
    background-color: #fff;
    border-radius: 6px;
    padding: 15px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    overflow-y: auto;
    font-size: 16px;
    line-height: 1.6;
  }
  
  /* Chat section styling */
  .chat-area {
    display: flex;
    flex-direction: column;
    height: 100%;
  }
  
  .chat-history {
    flex: 1;
    overflow-y: auto;
    padding: 15px;
    border: 1px solid #ddd;
    border-radius: 6px;
    margin-bottom: 10px;
    display: flex;
    flex-direction: column;
    gap: 8px;
  }
  
  /* Chat bubbles */
  .chat-bubble {
    padding: 10px 14px;
    border-radius: 12px;
    max-width: 70%;
    line-height: 1.4;
    display: inline-flex;
    word-wrap: break-word;
  }
  
  /* User message aligned to the right */
  .chat-bubble.user {
    background-color: #e8f4ff;
    color: #333;
    align-self: flex-end;
    margin-left: auto;
    text-align: right;
    justify-content: flex-end;
  }
  
  /* Gemini message aligned to the left */
  .chat-bubble.gemini {
    background-color: #4b7bec;
    color: white;
    align-self: flex-start;
    margin-right: auto;
    text-align: left;
    justify-content: flex-start;
  }
  
  /* Chat input and form */
  .chat-form {
    display: flex;
  }
  
  .chat-input {
    width: 100%;
    padding: 10px;
    border: 1px solid #ccc;
    border-radius: 6px;
    font-size: 16px;
    transition: border 0.3s ease;
  }
  
  .chat-input:focus {
    border-color: #4b7bec;
    outline: none;
  }

================
File: frontend/src/styles/summary.css
================
.container {
    display: flex;
    flex-direction: row;
}

================
File: frontend/src/App.css
================
/* Reset and global styles */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  font-family: 'Roboto', sans-serif; /* Modern font */
}

body {
  background-color: #f5f5f7;
  color: #333;
}

/* Main container styling */
.app-container {
  display: flex;
  flex-direction: row;
  height: 100vh;
  width: 100vw;
}

/* Video section styling */
.video-section {
  flex: 1.5;
  height: 100%;
  background-color: #ffffff;
  border-right: 2px solid #e0e0e0;
  box-shadow: 4px 0px 8px rgba(0, 0, 0, 0.05);
  display: flex;
  justify-content: center;
  align-items: center;
}

/* Notes/Chat section styling */
.notes-section {
  flex: 2;
  overflow-y: auto;
  height: 100%;
  padding: 20px;
  background-color: #fdfdfd;
}

/* Tab navigation styling */
.tab-buttons {
  display: flex;
  margin-bottom: 20px;
  justify-content: space-between;
}

.tab-buttons button {
  flex: 1;
  padding: 12px;
  background-color: #f0f0f5;
  color: #333;
  border: none;
  border-radius: 8px;
  margin-right: 8px;
  cursor: pointer;
  transition: all 0.3s ease;
  font-weight: bold;
}

.tab-buttons button:last-child {
  margin-right: 0;
}

.tab-buttons button.active {
  background-color: #4b7bec;
  color: white;
}

.tab-buttons button:hover {
  background-color: #e0e4ff;
  color: #4b7bec;
}

/* Chat/Notes content area */
.content-area {
  background-color: #ffffff;
  border-radius: 8px;
  padding: 20px;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
  max-height: calc(100vh - 100px);
  overflow-y: auto;
}

/* Chat bubbles styling */
.chat-bubble {
  display: inline-block;
  padding: 10px 15px;
  border-radius: 15px;
  margin-bottom: 10px;
  max-width: 80%;
  line-height: 1.4;
  box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.1);
}

.chat-bubble.user {
  background-color: #e1f5fe;
  color: #333;
  align-self: flex-end;
  margin-left: auto;
  text-align: right;
}

.chat-bubble.gemini {
  background-color: #4b7bec;
  color: white;
  align-self: flex-start;
  text-align: left;
}

/* Input styling */
input[type="text"] {
  width: 100%;
  padding: 12px;
  border: 1px solid #ccc;
  border-radius: 8px;
  margin-top: 10px;
  font-size: 16px;
  transition: border 0.3s ease;
}

input[type="text"]:focus {
  border-color: #4b7bec;
  outline: none;
}

================
File: frontend/src/App.js
================
// src/App.js
import React from 'react';
import { BrowserRouter as Router, Routes, Route } from "react-router-dom";
import { Landing } from "./pages/landing";
import { Meeting } from "./pages/meeting";
import { Summary } from "./pages/summary";
import { NotesProvider } from './context/NotesContext';

import './App.css';

const App = () => {
  return (
    <NotesProvider>
    <Router>
      <Routes>
        <Route exact path="/" element={<Landing />} />
        <Route exact path="/meeting" element={<Meeting />} />
        <Route exact path="/summary" element={<Summary />} />
      </Routes>
    </Router>
    </NotesProvider>

  );
};

export default App;

================
File: frontend/src/App.test.js
================
import { render, screen } from '@testing-library/react';
import App from './App';

test('renders learn react link', () => {
  render(<App />);
  const linkElement = screen.getByText(/learn react/i);
  expect(linkElement).toBeInTheDocument();
});

================
File: frontend/src/index.css
================
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}

================
File: frontend/src/index.js
================
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  // <React.StrictMode>
    <App />
  // </React.StrictMode>
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();

================
File: frontend/src/logo.svg
================
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 841.9 595.3"><g fill="#61DAFB"><path d="M666.3 296.5c0-32.5-40.7-63.3-103.1-82.4 14.4-63.6 8-114.2-20.2-130.4-6.5-3.8-14.1-5.6-22.4-5.6v22.3c4.6 0 8.3.9 11.4 2.6 13.6 7.8 19.5 37.5 14.9 75.7-1.1 9.4-2.9 19.3-5.1 29.4-19.6-4.8-41-8.5-63.5-10.9-13.5-18.5-27.5-35.3-41.6-50 32.6-30.3 63.2-46.9 84-46.9V78c-27.5 0-63.5 19.6-99.9 53.6-36.4-33.8-72.4-53.2-99.9-53.2v22.3c20.7 0 51.4 16.5 84 46.6-14 14.7-28 31.4-41.3 49.9-22.6 2.4-44 6.1-63.6 11-2.3-10-4-19.7-5.2-29-4.7-38.2 1.1-67.9 14.6-75.8 3-1.8 6.9-2.6 11.5-2.6V78.5c-8.4 0-16 1.8-22.6 5.6-28.1 16.2-34.4 66.7-19.9 130.1-62.2 19.2-102.7 49.9-102.7 82.3 0 32.5 40.7 63.3 103.1 82.4-14.4 63.6-8 114.2 20.2 130.4 6.5 3.8 14.1 5.6 22.5 5.6 27.5 0 63.5-19.6 99.9-53.6 36.4 33.8 72.4 53.2 99.9 53.2 8.4 0 16-1.8 22.6-5.6 28.1-16.2 34.4-66.7 19.9-130.1 62-19.1 102.5-49.9 102.5-82.3zm-130.2-66.7c-3.7 12.9-8.3 26.2-13.5 39.5-4.1-8-8.4-16-13.1-24-4.6-8-9.5-15.8-14.4-23.4 14.2 2.1 27.9 4.7 41 7.9zm-45.8 106.5c-7.8 13.5-15.8 26.3-24.1 38.2-14.9 1.3-30 2-45.2 2-15.1 0-30.2-.7-45-1.9-8.3-11.9-16.4-24.6-24.2-38-7.6-13.1-14.5-26.4-20.8-39.8 6.2-13.4 13.2-26.8 20.7-39.9 7.8-13.5 15.8-26.3 24.1-38.2 14.9-1.3 30-2 45.2-2 15.1 0 30.2.7 45 1.9 8.3 11.9 16.4 24.6 24.2 38 7.6 13.1 14.5 26.4 20.8 39.8-6.3 13.4-13.2 26.8-20.7 39.9zm32.3-13c5.4 13.4 10 26.8 13.8 39.8-13.1 3.2-26.9 5.9-41.2 8 4.9-7.7 9.8-15.6 14.4-23.7 4.6-8 8.9-16.1 13-24.1zM421.2 430c-9.3-9.6-18.6-20.3-27.8-32 9 .4 18.2.7 27.5.7 9.4 0 18.7-.2 27.8-.7-9 11.7-18.3 22.4-27.5 32zm-74.4-58.9c-14.2-2.1-27.9-4.7-41-7.9 3.7-12.9 8.3-26.2 13.5-39.5 4.1 8 8.4 16 13.1 24 4.7 8 9.5 15.8 14.4 23.4zM420.7 163c9.3 9.6 18.6 20.3 27.8 32-9-.4-18.2-.7-27.5-.7-9.4 0-18.7.2-27.8.7 9-11.7 18.3-22.4 27.5-32zm-74 58.9c-4.9 7.7-9.8 15.6-14.4 23.7-4.6 8-8.9 16-13 24-5.4-13.4-10-26.8-13.8-39.8 13.1-3.1 26.9-5.8 41.2-7.9zm-90.5 125.2c-35.4-15.1-58.3-34.9-58.3-50.6 0-15.7 22.9-35.6 58.3-50.6 8.6-3.7 18-7 27.7-10.1 5.7 19.6 13.2 40 22.5 60.9-9.2 20.8-16.6 41.1-22.2 60.6-9.9-3.1-19.3-6.5-28-10.2zM310 490c-13.6-7.8-19.5-37.5-14.9-75.7 1.1-9.4 2.9-19.3 5.1-29.4 19.6 4.8 41 8.5 63.5 10.9 13.5 18.5 27.5 35.3 41.6 50-32.6 30.3-63.2 46.9-84 46.9-4.5-.1-8.3-1-11.3-2.7zm237.2-76.2c4.7 38.2-1.1 67.9-14.6 75.8-3 1.8-6.9 2.6-11.5 2.6-20.7 0-51.4-16.5-84-46.6 14-14.7 28-31.4 41.3-49.9 22.6-2.4 44-6.1 63.6-11 2.3 10.1 4.1 19.8 5.2 29.1zm38.5-66.7c-8.6 3.7-18 7-27.7 10.1-5.7-19.6-13.2-40-22.5-60.9 9.2-20.8 16.6-41.1 22.2-60.6 9.9 3.1 19.3 6.5 28.1 10.2 35.4 15.1 58.3 34.9 58.3 50.6-.1 15.7-23 35.6-58.4 50.6zM320.8 78.4z"/><circle cx="420.9" cy="296.5" r="45.7"/><path d="M520.5 78.1z"/></g></svg>

================
File: frontend/src/reportWebVitals.js
================
const reportWebVitals = onPerfEntry => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;

================
File: frontend/src/setupTests.js
================
// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';

================
File: frontend/.gitignore
================
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# production
/build

# misc
.DS_Store
.env.local
.env.development.local
.env.test.local
.env.production.local

npm-debug.log*
yarn-debug.log*
yarn-error.log*

.env

================
File: frontend/package.json
================
{
  "name": "frontend",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@copilotkit/react-core": "^1.3.10",
    "@copilotkit/react-ui": "^1.3.10",
    "@copilotkit/runtime": "^1.3.10",
    "@daily-co/daily-js": "^0.73.0",
    "@google-cloud/vertexai": "^1.9.0",
    "@testing-library/jest-dom": "^5.17.0",
    "@testing-library/react": "^13.4.0",
    "@testing-library/user-event": "^13.5.0",
    "openai": "^4.70.2",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-markdown": "^9.0.1",
    "react-router-dom": "^6.27.0",
    "react-scripts": "5.0.1",
    "web-vitals": "^2.1.4"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}

================
File: frontend/README.md
================
# Getting Started with Create React App

This project was bootstrapped with [Create React App](https://github.com/facebook/create-react-app).

## Available Scripts

In the project directory, you can run:

### `npm start`

Runs the app in the development mode.\
Open [http://localhost:3000](http://localhost:3000) to view it in your browser.

The page will reload when you make changes.\
You may also see any lint errors in the console.

### `npm test`

Launches the test runner in the interactive watch mode.\
See the section about [running tests](https://facebook.github.io/create-react-app/docs/running-tests) for more information.

### `npm run build`

Builds the app for production to the `build` folder.\
It correctly bundles React in production mode and optimizes the build for the best performance.

The build is minified and the filenames include the hashes.\
Your app is ready to be deployed!

See the section about [deployment](https://facebook.github.io/create-react-app/docs/deployment) for more information.

### `npm run eject`

**Note: this is a one-way operation. Once you `eject`, you can't go back!**

If you aren't satisfied with the build tool and configuration choices, you can `eject` at any time. This command will remove the single build dependency from your project.

Instead, it will copy all the configuration files and the transitive dependencies (webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except `eject` will still work, but they will point to the copied scripts so you can tweak them. At this point you're on your own.

You don't have to ever use `eject`. The curated feature set is suitable for small and middle deployments, and you shouldn't feel obligated to use this feature. However we understand that this tool wouldn't be useful if you couldn't customize it when you are ready for it.

## Learn More

You can learn more in the [Create React App documentation](https://facebook.github.io/create-react-app/docs/getting-started).

To learn React, check out the [React documentation](https://reactjs.org/).

### Code Splitting

This section has moved here: [https://facebook.github.io/create-react-app/docs/code-splitting](https://facebook.github.io/create-react-app/docs/code-splitting)

### Analyzing the Bundle Size

This section has moved here: [https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size](https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size)

### Making a Progressive Web App

This section has moved here: [https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app](https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app)

### Advanced Configuration

This section has moved here: [https://facebook.github.io/create-react-app/docs/advanced-configuration](https://facebook.github.io/create-react-app/docs/advanced-configuration)

### Deployment

This section has moved here: [https://facebook.github.io/create-react-app/docs/deployment](https://facebook.github.io/create-react-app/docs/deployment)

### `npm run build` fails to minify

This section has moved here: [https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify](https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify)

================
File: src/services/__init__.py
================
"""
Services package initialization.
Contains service implementations for external integrations.
"""

from .email_service import EmailService

__all__ = ['EmailService']

================
File: src/services/email_service.py
================
from typing import List, Dict
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import InstalledAppFlow
from google.auth.transport.requests import Request
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError
import json
import os
import pickle
from pathlib import Path

class EmailService:
    """Simple Gmail service that returns first matching email"""
    
    SCOPES = ['https://www.googleapis.com/auth/gmail.readonly']
    CREDENTIALS_DIR = Path('.credentials')
    
    def __init__(self):
        # Create credentials directory if it doesn't exist
        self.CREDENTIALS_DIR.mkdir(exist_ok=True)
        self.service = self._get_gmail_service()

    def _get_gmail_service(self):
        """Get Gmail API service using existing token.json"""
        token_path = self.CREDENTIALS_DIR / 'token.json'
        
        if not token_path.exists():
            raise FileNotFoundError(
                f"token.json not found at {token_path}. "
                "Please ensure the file exists in the .credentials directory."
            )

        # Load credentials from token.json
        with open(token_path, 'r') as token_file:
            token_data = json.load(token_file)
            
        creds = Credentials.from_authorized_user_info(token_data, self.SCOPES)
        
        # Refresh token if expired
        if creds and creds.expired and creds.refresh_token:
            creds.refresh(Request())

        return build('gmail', 'v1', credentials=creds)

    async def search_emails(self, queries: List[str]) -> List[Dict]:
        """Search emails and return first result for each query"""
        results = []
        
        for query in queries:
            try:
                # Search for messages
                response = self.service.users().messages().list(
                    userId='me',
                    q=query,
                    maxResults=1  # Just get the first match
                ).execute()
                
                if 'messages' in response:
                    # Get the first message's details
                    msg_id = response['messages'][0]['id']
                    msg = self.service.users().messages().get(
                        userId='me',
                        id=msg_id,
                        format='metadata',
                        metadataHeaders=['subject', 'from', 'date']
                    ).execute()
                    
                    # Extract headers
                    headers = msg['payload']['headers']
                    subject = next(
                        (h['value'] for h in headers if h['name'].lower() == 'subject'),
                        '(no subject)'
                    )
                    sender = next(
                        (h['value'] for h in headers if h['name'].lower() == 'from'),
                        '(no sender)'
                    )
                    
                    # Create result
                    result = {
                        'id': msg_id,
                        'subject': subject,
                        'from': sender,
                        'url': f"https://mail.google.com/mail/u/0/#inbox/{msg_id}",
                        'query_used': query
                    }
                    
                    results.append(result)
                    
            except Exception as e:
                print(f"Error searching emails: {e}")
                continue
                
        return results

================
File: src/utils/__init__.py
================
"""
Utilities package initialization.
Contains utility classes and helper functions for email analysis and context management.

Classes:
    EmailQueryGenerator: Generates Gmail search queries from analyzed transcripts
    ContextProvider: Provides contextual information like dates and times
"""

from .query_generator import EmailQueryGenerator
from .context_provider import ContextProvider

# Define which classes/functions should be available when using 'from src.utils import *'
__all__ = [
    'EmailQueryGenerator',
    'ContextProvider'
]

# Version tracking
__version__ = '0.1.0'

# Commonly used instances
default_query_generator = EmailQueryGenerator()
context_provider = ContextProvider()

# Helper function for easy access to current context
def get_current_context():
    """Get the current date and time context"""
    return context_provider.get_current_context()

# Export helper functions as well
__all__ += ['get_current_context']

================
File: src/utils/context_provider.py
================
from datetime import datetime, timedelta
from typing import Dict, Optional

class ContextProvider:
    """Provides contextual information for email analysis"""
    
    def __init__(self):
        self.date_keywords = {
            "yesterday": 1,
            "last week": 7,
            "last month": 30,
            "today": 0
        }
    
    def get_current_context(self) -> Dict:
        """Get current date-time context"""
        now = datetime.now()
        return {
            "current_date": now.strftime("%Y/%m/%d"),
            "current_time": now.strftime("%H:%M:%S"),
            "current_day": now.strftime("%A"),
            "yesterday": (now - timedelta(days=1)).strftime("%Y/%m/%d"),
            "last_week": (now - timedelta(days=7)).strftime("%Y/%m/%d"),
            "last_month": (now - timedelta(days=30)).strftime("%Y/%m/%d")
        }

    def parse_date_reference(self, text: str) -> Dict[str, Optional[str]]:
        """Parse relative date references into Gmail date formats"""
        today = datetime.now()
        
        # Check for specific date references
        for keyword, days in self.date_keywords.items():
            if keyword in text.lower():
                if days == 0:  # today
                    date = today
                else:
                    date = today - timedelta(days=days)
                    
                # For ranges like "last week", "last month"
                if keyword in ["last week", "last month"]:
                    return {
                        "after": (date - timedelta(days=7 if keyword == "last week" else 30)).strftime("%Y/%m/%d"),
                        "before": today.strftime("%Y/%m/%d")
                    }
                else:  # for specific days like "yesterday"
                    return {
                        "after": date.strftime("%Y/%m/%d"),
                        "before": (date + timedelta(days=1)).strftime("%Y/%m/%d")
                    }
        
        return {"after": None, "before": None}

    @staticmethod
    def format_date_for_query(date_str: Optional[str]) -> str:
        """Format a date string for Gmail query"""
        try:
            date = datetime.strptime(date_str, "%Y/%m/%d")
            return date.strftime("%Y/%m/%d")
        except (ValueError, TypeError):
            return ""

================
File: src/utils/query_generator.py
================
from typing import List, Dict, Optional
from datetime import datetime, timedelta

class EmailQueryGenerator:
    """Generate Gmail search queries based on transcript context"""
    
    def __init__(self):
        self.date_keywords = {
            "yesterday": 1,
            "last week": 7,
            "last month": 30,
            "today": 0
        }

    def parse_date_reference(self, text: str) -> Dict[str, str]:
        """Parse relative date references into Gmail date formats"""
        today = datetime.now()
        
        # Check for specific date references
        for keyword, days in self.date_keywords.items():
            if keyword in text.lower():
                if days == 0:  # today
                    date = today
                else:
                    date = today - timedelta(days=days)
                    
                # For ranges like "last week", "last month"
                if keyword in ["last week", "last month"]:
                    return {
                        "after": (date - timedelta(days=7 if keyword == "last week" else 30)).strftime("%Y/%m/%d"),
                        "before": today.strftime("%Y/%m/%d")
                    }
                else:  # for specific days like "yesterday"
                    return {
                        "after": date.strftime("%Y/%m/%d"),
                        "before": (date + timedelta(days=1)).strftime("%Y/%m/%d")
                    }
        
        return {"after": None, "before": None}

    def generate_queries(self, analysis_result: Dict) -> List[str]:
        """
        Generate Gmail search queries based on LLM analysis
        
        Args:
            analysis_result: Dict containing:
                - sender: str
                - recipients: List[str]
                - subject: str
                - date_range: Dict[str, str]
                - attachment_type: str
                
        Returns:
            List of Gmail search query strings
        """
        queries = []
        
        # Extract components with safe gets
        sender = analysis_result.get("sender", "")
        recipients = analysis_result.get("recipients", [])
        subject = analysis_result.get("subject", "")
        attachment_type = analysis_result.get("attachment_type", "")
        date_range = analysis_result.get("date_range", {})
        
        # Build base query
        if sender:
            base_query = f"from:{sender}"
            queries.append(base_query)
            
            # Add recipient if available
            if recipients:
                for recipient in recipients:
                    queries.append(f"{base_query} to:{recipient}")
            
            # Add subject if available
            if subject:
                queries.append(f"{base_query} subject:({subject})")
            
            # Add attachment info if available
            if attachment_type:
                queries.append(f"{base_query} has:attachment filename:{attachment_type}")
        
        # Add date constraints
        if date_range:
            date_parts = []
            if date_range.get("after"):
                date_parts.append(f"after:{date_range['after']}")
            if date_range.get("before"):
                date_parts.append(f"before:{date_range['before']}")
            
            if date_parts:
                date_str = " ".join(date_parts)
                # Add dates to existing queries
                new_queries = []
                for query in queries:
                    new_queries.append(f"{query} {date_str}")
                queries.extend(new_queries)
        
        return queries if queries else [""]  # Return empty query if no components found

================
File: src/__init__.py
================
"""
Source package initialization.
This file marks the src directory as a Python package and provides convenient imports
for commonly used components.
"""

from pathlib import Path

# Define important paths
SRC_ROOT = Path(__file__).parent
PROJECT_ROOT = SRC_ROOT.parent

# Version info
__version__ = "0.1.0"

# Import commonly used components for easier access
from .agent import EmailQueryAgent, MeetingAnalysisAgent
from .services.email_service import EmailService
from .utils.query_generator import EmailQueryGenerator

# Define what should be available when someone does 'from src import *'
__all__ = [
    'EmailQueryAgent',
    'MeetingAnalysisAgent',
    'EmailService',
    'EmailQueryGenerator'
]

================
File: src/agent.py
================
import os
from typing import Optional, List, Dict
from llama_index.llms.anthropic import Anthropic
from llama_index.llms.openai import OpenAI
from llama_index.core.agent import FunctionCallingAgent
from llama_index.core.llms import ChatMessage, LLM  # Added LLM import
from llama_index.core.tools import FunctionTool

from src.services.email_service import EmailService

import json
import re
from typing import Dict, Any

from src.utils import *

# Define a simple dummy function
def noop_function():
    """A no-operation function."""
    return {"status": "No operation performed"}

dummy_tool = FunctionTool.from_defaults(
    noop_function,
    name="NoOpTool",
    description="A dummy tool for testing purposes"
)

class MeetingAnalysisAgent:
    def __init__(self, api_key: Optional[str] = None):
        """Initialize the meeting analysis agent"""
        self.api_key = api_key or os.getenv("ANTHROPIC_API_KEY")
        if not self.api_key:    
            raise ValueError("Anthropic API key must be provided")

        self.llm = Anthropic(
            model="claude-3-5-sonnet-20241022",
            api_key=self.api_key
        )
        
        self.agent = self._initialize_agent()

    def _initialize_agent(self) -> FunctionCallingAgent:
        """Initialize the function calling agent with system prompt"""
        prefix_messages = [
            ChatMessage(
                role="system",
                content=(
                    "You are a real-time meeting analysis assistant. Your task is to process "
                    "new meeting transcript segments and update the existing summary. "
                    
                    "You will receive:"
                    "1. The existing summary (if any)"
                    "2. A new transcript segment"
                    
                    "Provide an updated summary that:"
                    "- Incorporates new information with existing points"
                    "- Removes redundancies"
                    "- Updates existing points with new context"
                    "- Maintains clear, concise bullet points"
                    
                    "Format the output into these sections (only when relevant):"
                    " Summary Points:"
                    " Action Items:"
                    " Decisions Made:"
                    " Questions Raised:"
                    " Follow-up Required:"
                    
                    "Keep the style consistent and focus on clarity and brevity."
                )
            )
        ]
        
        return FunctionCallingAgent.from_tools(
            tools=[dummy_tool],
            llm=self.llm,
            verbose=True,
            prefix_messages=prefix_messages
        )

    def process_segment(self, existing_summary: str, new_transcript: str) -> str:
        """Process a new transcript segment and update the summary"""
        prompt = (
            f"Existing Summary:\n{existing_summary or 'No existing summary.'}\n\n"
            f"New Transcript Segment:\n{new_transcript}\n\n"
            "Please provide an updated summary incorporating the new information."
        )

        response = self.agent.chat(prompt)
        return response.response
class EmailQueryAgent:
    def __init__(self, llm_provider: str = "openai", api_key: Optional[str] = None):
        """Initialize email query agent"""
        self.llm = self._initialize_llm(llm_provider, api_key)
        self.email_service = EmailService()
        self.agent = self._initialize_agent()

    def _initialize_llm(self, provider: str, api_key: Optional[str] = None) -> LLM:
        """Initialize the chosen LLM provider"""
        if provider == "openai":
            api_key = api_key or os.getenv("OPENAI_API_KEY")
            if not api_key:
                raise ValueError("OpenAI API key must be provided")
            return OpenAI(
                model="gpt-4o-mini",
                api_key=api_key,
                temperature=0.1
            )
        elif provider == "anthropic":
            api_key = api_key or os.getenv("ANTHROPIC_API_KEY")
            if not api_key:
                raise ValueError("Anthropic API key must be provided")
            return Anthropic(
                model="claude-3-5-sonnet-20241022",
                api_key=api_key
            )
        else:
            raise ValueError(f"Unsupported LLM provider: {provider}")

    def _initialize_agent(self) -> FunctionCallingAgent:
        """Initialize the agent with email search prompts"""
        prefix_messages = [
            ChatMessage(
                role="system",
                content=(
                    "You are an AI assistant that helps find emails by creating Gmail search queries. "
                    "Given a conversation snippet, create a simple Gmail query. "
                    "\n\nRules:"
                    "\n- If someone mentions an email from a person, use 'from:person'"
                    "\n- If they mention a subject, add 'subject:topic'"
                    "\n- Keep queries simple and direct"
                    "\n- Return ONLY the query string, no other text"
                )
            )
        ]
        
        return FunctionCallingAgent.from_tools(
            tools=[],
            llm=self.llm,
            verbose=True,
            prefix_messages=prefix_messages
        )

    async def analyze_transcript_segment(self, transcript: str) -> Dict[str, Any]:
        """Find relevant email from transcript segment"""
        try:
            # Generate simple search query
            response = self.agent.chat(transcript)
            query = response.response.strip()
            
            # Search emails using query
            results = await self.email_service.search_emails([query])
            
            if results and len(results) > 0:
                return {
                    'status': 'success',
                    'query_used': query,
                    'email_found': results[0]
                }
            else:
                return {
                    'status': 'no_results',
                    'query_used': query
                }
                
        except Exception as e:
            return {
                'status': 'error',
                'error': str(e)
            }

================
File: .gitignore
================
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
env/
venv/
.env
*.pyc

# IDE
.vscode/
.idea/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Distribution / packaging
dist/
build/
*.egg-info/

# Virtual environment
venv/
env/
ENV/

.credentials

================
File: README.md
================
# ConveneAI
Intelligent meeting tool that works with your data


## Backend Setup
# ConveneAI Backend

Backend service that processes meeting transcripts to generate relevant email queries.

## Setup

### 1. Create Conda Environment

```bash
# Create environment
conda create -n meeting-assistant python=3.10
conda activate meeting-assistant
```

### 2. Install Dependencies

```bash
# Add required packages
pip install requirements.txt
```

### 3. Environment Variables

Create `.env` file in project root:
```env
OPENAI_API_KEY=
FLASK_ENV=development
FLASK_DEBUG=1
ANTHROPIC_API_KEY=
```

## Running the Server

```bash
# From project root
python backend/run.py
```

Server runs on `http://localhost:5000`

## Testing the Endpoints

### 1. Health Check
```bash
curl http://localhost:5000/health
```

### 2. Test with Sample Data
```bash
curl http://localhost:5000/demo-queries
```

### 3. Test with Custom Transcript
```bash
curl -X POST http://localhost:5000/analyze-transcript \
  -H "Content-Type: application/json" \
  -d '{
    "transcript": "John: Can you find that budget email from Sarah? Mary: The one from last week with the Excel file?"
  }'
````

================
File: requirements.txt
================
asgiref                            3.8.1
llama-index-core                   0.11.21
llama-index-llms-anthropic         0.3.8
llama-index-llms-openai            0.2.16
openai                             1.53.0
python-dotenv                      1.0.1
google-auth-oauthlib
google-api-python-client

================
File: setup.py
================
import os
import sys
from pathlib import Path

def check_dependencies():
    """Check if all required packages are installed"""
    required_packages = [
        'flask',
        'python-dotenv',
        'hypercorn',
        'asgiref',
        'llama-index-llms-anthropic'
    ]
    
    missing_packages = []
    for package in required_packages:
        try:
            __import__(package.replace('-', '_'))
        except ImportError:
            missing_packages.append(package)
    
    if missing_packages:
        print("Missing required packages. Installing...")
        os.system(f"pip install {' '.join(missing_packages)}")
    else:
        print("All required packages are installed.")

def check_env_file():
    """Check if .env file exists and has required variables"""
    env_path = Path('.env')
    
    if not env_path.exists():
        print("Creating .env file...")
        with open(env_path, 'w') as f:
            f.write("ANTHROPIC_API_KEY=your_key_here\n")
        print("Please edit .env file and add your Anthropic API key")
        return False
    
    return True

def check_directory_structure():
    """Check if all required directories and files exist"""
    required_structure = {
        'backend/app': ['__init__.py', 'routes.py'],
        'backend/config': ['__init__.py'],
        'backend': ['run.py'],
        'src/services': ['email_service.py'],
        'src/utils': ['query_generator.py'],
        'src': ['agent.py']
    }
    
    missing_items = []
    for directory, files in required_structure.items():
        dir_path = Path(directory)
        if not dir_path.exists():
            missing_items.append(f"Directory: {directory}")
            continue
        
        for file in files:
            file_path = dir_path / file
            if not file_path.exists():
                missing_items.append(f"File: {directory}/{file}")
    
    return missing_items

def main():
    """Main setup function"""
    print("Starting setup...")
    
    # Check dependencies
    check_dependencies()
    
    # Check directory structure
    missing_items = check_directory_structure()
    if missing_items:
        print("\nMissing required files/directories:")
        for item in missing_items:
            print(f"- {item}")
        print("\nPlease ensure all required files are present before running the application.")
        sys.exit(1)
    
    # Check .env file
    if not check_env_file():
        print("Please add your Anthropic API key to the .env file before running the application.")
        sys.exit(1)
    
    print("\nSetup complete! You can now run the application with:")
    print("python backend/run.py")

if __name__ == "__main__":
    main()
